# vim: set ft=zsh:

##
# Triggers a panic.
#
# Panics are intended for 'unrecoverable' logic errors only. They are **not** a
# replacement for exceptions (which shu doesn't provide). That said, panics
# *can* be ignored by setting `SHU_PANIC_IGNORE` to a non-zero value.
#
# Panics also produce a trace-back if `SHU_PANIC_TRACE` is set to a non-zero
# value. If >1, the trace-back includes file-absolute line numbers.
#
# This function uses `SHU_FD_STDERR` to bypass any redirection of `stderr` which
# might have taken place since the script was started.
#
# Panics send `SIGTERM` to the parent shell instance to ensure that it exits.
#
# @module core
#
# @param $1 ...
#   (optional) Zero or more strings to use as an error message. Multiple strings
#   are concatenated by spaces prior to being passed to `printf` (panic error
#   messages do not respect verbosity settings). Empty arguments are **not**
#   elided.
#
# @return SHU_EX_PANIC

local    i identifier line_no caller trace_line
local -a trace

# Build trace-back
(( $+functrace && $#functrace )) && {
	for i in {1..$#functrace}; do
		identifier=${functrace[i]%:*}
		   line_no=${functrace[i]##*:}

		# Colourise and format depending on whether the identifier represents a
		# file, a special context like `(eval)`, or a regular function
		if
			{ [[ $identifier == */* ]] && (( ! $+functions[$identifier] )) } ||
			{ (( i == $#functrace ))   && [[ $identifier == $SHU_ARGZERO ]] }
		then
			(( i == 1 )) && caller="{${identifier:t}}"
			identifier="${SHU_ANSI[fg:yellow2]}{${identifier}}${SHU_ANSI[reset]}"

		elif [[ $identifier == '('*')' ]]; then
			(( i == 1 )) && caller="${identifier}"
			identifier="${SHU_ANSI[fg:yellow2]}${identifier}${SHU_ANSI[reset]}"

		else
			(( i == 1 )) && caller="${identifier}()"
			identifier="${SHU_ANSI[fg:yellow2]}${identifier}()${SHU_ANSI[reset]}"
		fi

		 trace_line="${identifier}"
		trace_line+=" @ ${SHU_ANSI[fg:magenta2]}${line_no}${SHU_ANSI[reset]}"

		# Only add file-level info if requested
		(( SHU_PANIC_TRACE > 1 )) && {
			identifier=${${funcfiletrace[i]%:*}:-$ZSH_NAME}
			   line_no=${funcfiletrace[i]##*:}
			trace_line+=' '
			trace_line+='('
			trace_line+="${SHU_ANSI[fg:yellow2]}${identifier:t}${SHU_ANSI[reset]}"
			trace_line+=' @ '
			trace_line+="${SHU_ANSI[fg:magenta2]}${line_no}${SHU_ANSI[reset]}"
			trace_line+=')'
		}

		trace+=( $trace_line )
	done
}

printf >&$SHU_FD_STDERR \
	'%s: %sPanic in %s%s%s\n' \
	$SHU_ARGZERO_TAIL \
	"${SHU_ANSI[fg:red]}" \
	${caller:-(unknown)} \
	"${@:+: ${(j< >)@}}" \
	"${SHU_ANSI[reset]}"

(( SHU_PANIC_TRACE )) &&
(( $#trace )) && {
	printf >&$SHU_FD_STDERR \
		'%s: Trace-back (most recent call on top):\n' \
		$SHU_ARGZERO_TAIL

	for i in {1..$#trace}; do
		printf >&$SHU_FD_STDERR \
			'%3s. %s\n' $(( $#trace + 1 - i )) $trace[i]
	done
}

if [[ $- == *i* ]] || (( SHU_PANIC_IGNORE )); then
	# Set an exit trap to force the caller to immediately return, unless we're at
	# the top level of a script or an interactive shell
	(( ZSH_SUBSHELL || $#funcstack > 1 )) &&
	trap 'return SHU_EX_PANIC' EXIT
	return SHU_EX_PANIC
fi

kill -TERM $$
exit SHU_EX_PANIC

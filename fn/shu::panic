# vim: set ft=zsh:

##
# Triggers a panic.
#
# Panics are intended for 'unrecoverable' logic errors only. They are **not** a
# replacement for exceptions (which shu doesn't provide). That said, panics
# *can* be ignored â€” please refer to `shu::ignpanic` for details.
#
# This function uses `SHU_FD_STDERR` to bypass any redirection of `stderr` which
# might have taken place since the script was started.
#
# Panics are made to propagate up sub-shells by sending `SIGUSR2` to the shell.
#
# @module core
#
# @see shu::ignpanic
#
# @param -q (optional) Suppress trace-back.
# @param -v (optional) Show trace-back. This is the default.
#
# @param $1 ...
#   (optional) Zero or more strings to use as an error message. Multiple strings
#   are concatenated by spaces prior to being passed to `shu:io:pputs`. Empty
#   arguments are **not** elided.
#
# @return SHU_EX_PANIC

local    i identifier line_no caller trace_line interactive
local -a trace

[[ $- == *i* ]] && interactive=1

# Build trace-back
(( $+functrace && $#functrace )) && {
	for i in {1..$#functrace}; do
		identifier=${functrace[i]%:*}
		   line_no=${functrace[i]##*:}

		# Colourise and format depending on whether the identifier represents a
		# file, a special context like `(eval)`, or a regular function
		if
			{ [[ $identifier == */* ]] && (( ! $+functions[$identifier] )) } ||
			{ (( i == $#functrace ))   && [[ $identifier == $SHU_ARGZERO ]] }
		then
			(( i == 1 )) && caller="{${identifier:t}}"
			identifier="${SHU_ANSI[fg:yellow2]}{${identifier}}${SHU_ANSI[reset]}"

		elif [[ $identifier == '('*')' ]]; then
			(( i == 1 )) && caller="${identifier}"
			identifier="${SHU_ANSI[fg:yellow2]}${identifier}${SHU_ANSI[reset]}"

		else
			(( i == 1 )) && caller="${identifier}()"
			identifier="${SHU_ANSI[fg:yellow2]}${identifier}()${SHU_ANSI[reset]}"
		fi

		 trace_line="${identifier}"
		trace_line+=" @ ${SHU_ANSI[fg:magenta2]}${line_no}${SHU_ANSI[reset]}"

		# Only add file-level info if requested
		(( SHU_PANIC_TRACE > 1 )) && {
			identifier=${${funcfiletrace[i]%:*}:-$ZSH_NAME}
			   line_no=${funcfiletrace[i]##*:}
			trace_line+=' '
			trace_line+='('
			trace_line+="${SHU_ANSI[fg:yellow2]}${identifier:t}${SHU_ANSI[reset]}"
			trace_line+=' @ '
			trace_line+="${SHU_ANSI[fg:magenta2]}${line_no}${SHU_ANSI[reset]}"
			trace_line+=')'
		}

		trace+=( $trace_line )
	done
}

shu:io:pputf >&$SHU_FD_STDERR '%sPanic in %s%s%s\n' \
	"${SHU_ANSI[fg:red]}" \
	${caller:-(unknown)} \
	${@:+: ${(j< >)@}} \
	"${SHU_ANSI[reset]}"


(( SHU_PANIC_TRACE )) &&
(( $#trace )) && {
	shu:io:pputs >&$SHU_FD_STDERR 'Trace-back (most recent call on top):'

	for i in {1..$#trace}; do
		shu:io:putf >&$SHU_FD_STDERR \
			'%3s. %s\n' $(( $#trace + 1 - i )) $trace[i]
	done
}

(( interactive || SHU_PANIC_IGNORE > 0 )) && {
	# Set an exit trap to force the caller to immediately return, unless we're
	# at the top level of a script or an interactive shell
	(( ZSH_SUBSHELL || $#funcstack > 1 )) &&
	trap 'return SHU_EX_PANIC' EXIT
	return SHU_EX_PANIC
}

# Kill the entire shell
kill -TERM $$
exit SHU_EX_PANIC

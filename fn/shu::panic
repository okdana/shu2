# vim: set ft=zsh:

##
# Triggers a panic.
#
# Panics are intended for 'unrecoverable' logic errors only. They are **not** a
# replacement for exceptions (which shu doesn't provide). That said, panics
# *can* be ignored â€” please refer to `shu::ignpanic` for details.
#
# This function uses `SHU_FD_STDERR` to bypass any redirection of `stderr` which
# might have taken place since the script was started.
#
# Panics are made to propagate up sub-shells by sending `SIGUSR2` to the shell.
#
# @module core
#
# @see shu::ignpanic
#
# @param -q (optional) Suppress trace-back.
# @param -v (optional) Show trace-back. This is the default.
#
# @param $1 ...
#   (optional) Zero or more strings to use as an error message. Multiple strings
#   are concatenated by spaces prior to being passed to `shu:io:pputs`. Empty
#   arguments are **not** elided.
#
# @return SHU_EX_PANIC
shu::panic() {
	local    i identifier line_no caller trace_line interactive
	local -a trace

	[[ $- == *i* ]] && interactive=1

	# Build trace-back
	(( $+functrace && $#functrace )) && {
		for i in {1..$#functrace}; do
			identifier=${functrace[i]%:*}
			   line_no=${functrace[i]##*:}

			# Colourise file names differently, and wrap them in braces
			if
				{ [[ $identifier == */* ]] && (( ! $+functions[$identifier] )) } ||
				{ (( i == $#functrace ))   && [[ $identifier == $SHU_ARGZERO ]] }
			then
				(( i == 1 )) && caller="{${identifier:t}}"
				identifier="${SHU_ANSI[fg:cyan]}{${identifier}}${SHU_ANSI[fg:reset]}"
			else
				(( i == 1 )) && caller="${identifier}()"
				identifier="${SHU_ANSI[fg:green]}${identifier}()${SHU_ANSI[fg:reset]}"
			fi

			 trace_line="${identifier}"
			trace_line+=" @ ${SHU_ANSI[fg:magenta]}${line_no}${SHU_ANSI[fg:reset]}"

			# Only add file-level info if requested
			(( SHU_PANIC_TRACE > 1 )) && {
				identifier=${funcfiletrace[i]%:*}
				   line_no=${funcfiletrace[i]##*:}
				trace_line+=' '
				trace_line+='('
				trace_line+="${SHU_ANSI[fg:cyan]}${identifier:t}${SHU_ANSI[fg:reset]}"
				trace_line+=' @ '
				trace_line+="${SHU_ANSI[fg:magenta]}${line_no}${SHU_ANSI[fg:reset]}"
				trace_line+=')'
			}

			trace+=( $trace_line )
		done
	}

	shu:io:pputf >&$SHU_FD_STDERR '%sPanic! %s%s%s\n' \
		"${SHU_ANSI[fg:red]}" \
		${caller:-?} \
		${@:+: ${(j< >)@}} \
		"${SHU_ANSI[reset]}"

	(( SHU_PANIC_TRACE )) &&
	(( $#trace )) && {
		shu:io:pputs >&$SHU_FD_STDERR 'Trace-back (most recent call on top):'

		for i in {1..$#trace}; do
			shu:io:putf >&$SHU_FD_STDERR \
				'%3s. %s\n' $(( $#trace + 1 - i )) $trace[i]
		done
	}

	(( interactive || SHU_PANIC_IGNORE > 0 )) && {
		# Set an exit trap to force the caller to immediately return, unless we're
		# at the top level of a script or an interactive shell
		(( ZSH_SUBSHELL || $#funcstack > 1 )) &&
		trap 'return SHU_EX_PANIC' EXIT
		return SHU_EX_PANIC
	}

	# Kill the entire shell
	kill -TERM $$
	exit SHU_EX_PANIC
}

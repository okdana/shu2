# vim: set ft=zsh:

##
# Prints a new-line-terminated string prefixed by the name of the calling
# script.
#
# Aside from the addition of the prefix, this function behaves identically to
# `shu:io:puts`.
#
# @module io
#
# @see printf
# @see shu:io:puts
#
# @param -<num>, -a, -n, -N, -q, -Q, -v, -V, -x, -X
#   (optional) See `shu:io:puts`.
#
# @param $1 ...
#   (optional) Zero or more strings to print. Multiple strings are concatenated
#   by spaces prior to being passed to `printf`. Empty arguments are **not**
#   elided.
#
# @return According to `printf`.

local OPTARG OPTIND opt last_opt last_num_optind
local indent cmp=$SHU_VERBOSITY_NORMAL op='<=' exact

while getopts ':0123456789anNqQvVxX' opt; do
	# Clauses here are ordered roughly according to frequency of use
	case $opt in
		'v'|'V')
			if [[ $last_opt == $opt ]]; then
				(( cmp < SHU_VERBOSITY_VERBOSE5 )) && (( cmp++ ))
			else
				cmp=$SHU_VERBOSITY_VERBOSE1
				 op='<='
				[[ $opt == V ]] && op='>='
			fi
			;;
		'q'|'Q')
			if [[ $last_opt == $opt ]]; then
				(( cmp > SHU_VERBOSITY_QUIET5 )) && (( cmp-- ))
			else
				cmp=$SHU_VERBOSITY_QUIET1
				 op='<='
				[[ $opt == Q ]] && op='>='
			fi
			;;
		'n'|'N')
			cmp=$SHU_VERBOSITY_NORMAL
			 op='<='
			[[ $opt == N ]] && op='>='
			;;
		'a')
			cmp=$SHU_VERBOSITY
			 op='=='
			;;
		[0-9])
			if (( last_num_optind != OPTIND )) || [[ $last_opt != [0-9] ]]; then
				indent=
			fi
			indent+=$opt
			last_num_optind=$OPTIND
			;;
		'x') exact=1 ;;
		'X') exact=0 ;;
		# Errors
		':') shu::panic "Missing argument to option: ${(l:2::-:)OPTARG}" ;;
		'?') shu::panic "Invalid option: ${(l:2::-:)OPTARG}" ;;
		*)   shu::panic "Invalid option: ${(l:2::-:)opt}" ;;
	esac
	last_opt=$opt
done

(( exact )) && op='=='
(( cmp $op SHU_VERBOSITY )) || return 0

shift $(( OPTIND - 1 ))

printf "${(l:$indent:: :):-}%s: %s\n" $SHU_ARGZERO_TAIL "${(j< >)@}"
return $?

# vim: set ft=zsh:

##
# Prints a new-line-terminated string prefixed by the name of the calling
# script.
#
# Aside from the addition of the prefix, this function behaves identically to
# `shu::puts`.
#
# @module core
#
# @see printf
# @see shu::puts
#
# @param -a, -n, -q, -qq, -v, -vv, -vvv (optional) See `shu::puts`.
#
# @param $1 ...
#   (optional) Zero or more strings to print. Multiple strings are concatenated
#   by spaces prior to being passed to `printf`. Empty arguments are **not**
#   elided.
#
# @return According to `printf`.
shu::pputs() {
	case ${1:-} in
		--)
			;;
		-a)
			shift
			;;
		-n)
			(( SHU_VERBOSITY == SHU_VERBOSITY_NORMAL )) || return 0
			shift
			;;
		-q)
			(( SHU_VERBOSITY <= SHU_VERBOSITY_QUIET )) || return 0
			shift
			;;
		-qq)
			(( SHU_VERBOSITY <= SHU_VERBOSITY_VERY_QUIET )) || return 0
			shift
			;;
		-v)
			(( SHU_VERBOSITY >= SHU_VERBOSITY_VERBOSE )) || return 0
			shift
			;;
		-vv)
			(( SHU_VERBOSITY >= SHU_VERBOSITY_VERY_VERBOSE )) || return 0
			shift
			;;
		-vvv)
			(( SHU_VERBOSITY >= SHU_VERBOSITY_DEBUG )) || return 0
			shift
			;;
		[+-]*)
			shu::panic "Invalid option: ${1}"
			;;
		*)
			(( SHU_VERBOSITY < SHU_VERBOSITY_NORMAL )) && return 0
			;;
	esac

	[[ ${1:-} == -- ]] && shift

	printf '%s: %s\n' $SHU_ARGZERO_TAIL "${(j< >)@}"
	return $?
}

# vim: set ft=zsh:

##
# Tests whether the given command yields the expected result.
#
# @module test
#
# @param +A <name>
#   (optional) Assign the result to a pre-defined association with the name
#   <name>. The following fields are provided:
#
#   * pass        — 1 if the assertion passed, 0 if not
#   * return      — The return status of the command
#   * result      — The output of the command
#   * expected    — The expected result or return status ($1)
#   * operator    — The normalised operator ($2)
#   * command     — The command string ($3 ...)
#   * description — The user's description
#   * summary     — The summary of the assertion (default description)
#
#   Note that, somewhat unusually, use of this option does not disable the
#   normal output of the function; use `-q` for that.
#
# @param +C
#   (optional) Disable ANSI formatting.
#
# @param -d <description>
#   (optional) Set a description to be used in PASS/FAIL message.
#
# @param -D
#   (optional) Use default description in PASS/FAIL message. This option
#   overrides `-d` no matter where it appears on the command line.
#
# @param -e
#   (optional) Pass $3 as a string to `eval`.
#
# @param -F
#   (optional) Show PASS/FAIL message only on failure.
#
# @param -p
#   (optional) Panic if the assertion fails.
#
# @param -P
#   (optional) Show PASS/FAIL message only on success.
#
# @param -q
#   (optional) Suppress PASS/FAIL message.
#
# @param -r
#   (optional) Treat $1 as a return code rather than an output string.
#
# @param -s
#   (optional) Capture only the executed command's `stdout`; discard `stderr`.
#
# @param -S
#   (optional) Capture only the executed command's `stderr`; discard `stdout`.
#
# @param -r
#   (optional) Treat $1 as a return code rather than an output string.
#
# @param $1
#   The output text or (with `-r`) return code that the executed command is
#   expected to produce.
#
# @param $2
#   An operator indicating the expected relationship between $1 and $3.
#   Supported operators include:
#
#   * `eq`, `=`,  `==` — $1 is equal to $3
#   * `ne`, `!=`, `<>` — $1 is not equal to $3
#   * `gl`, `~`        — $1 is an extended glob matching $3
#   * `re`, `=~`       — $1 is a regular expression matching $3
#   * `le`, `<=`, `=<` — $1 is equal to or less than $3 (with `-r` only)
#   * `lt`, `<`        — $1 is less than $3 (with `-r` only)
#   * `ge`, `>=`, `=>` — $1 is equal to or greater than $3 (with `-r` only)
#   * `gt`, `>`        — $1 is greater than $3 (with `-r` only)
#
# @param $3 ...
#   The command (and any arguments) to be executed, or (with `-e`) a string to
#   be passed to `eval`. Multiple strings will be concatenated by spaces when
#   used with `-e`.
#
# @return 0 on success, >0 on failure.

local    OPTARG OPTIND __opt
local    __to_assoc __desc __no_desc __eval_cmd
local    __show=-1 __fail_panics __quiet __compare_ret __discard_fd
local    __expect __op __res __ret __pass __cmd_str __summary
local -a __cmd
local -A __assoc SHU_ANSI=( "${(@kv)SHU_ANSI}" )

while getopts ':A:Cd:DeFpPqrsS' __opt; do
	case $__opt in
		# Assign result to association
		'+A')
			(( ${(P)+OPTARG} )) ||
			shu::panic "No such association: ${OPTARG}"
			[[ "${(Pt)OPTARG}-" == association-* ]] ||
			shu::panic "No such association: ${OPTARG}"

			 __to_assoc=$OPTARG
			;;
		# Disable ANSI formatting
		'+C') SHU_ANSI=( "${(@kv)SHU_ANSI_INACTIVE}" ) ;;
		# Set assertion description
		'd') __desc=$OPTARG ;;
		# Use automatic assertion description
		'D') __no_desc=1 ;;
		# Treat $3 as `eval` string
		'e') __eval_cmd=1 ;;
		# Show PASS/FAIL on fail only
		'F') __show=0 ;;
		# Panic on assertion failure
		'p') __fail_panics=1 ;;
		# Show PASS/FAIL on pass only
		'P') __show=1 ;;
		# Decrease output verbosity
		'q') __quiet=-q ;;
		# Treat $1 as return code
		'r') __compare_ret=1 ;;
		# Discard stderr
		's') __discard_fd=2 ;;
		# Discard stdout
		'S') __discard_fd=1 ;;
		# Errors
		':') shu::panic "Missing argument to option: ${(l:2::-:)OPTARG}" ;;
		'?') shu::panic "Invalid option: ${(l:2::-:)OPTARG}" ;;
		*)   shu::panic "Invalid option: ${(l:2::-:)__opt}" ;;
	esac
done

shift $(( OPTIND - 1 ))

(( $# >= 3 )) || shu::panic 'Too few arguments'

__expect=$1
    __op=$2
   __cmd=( "${@:3}" )

(( __compare_ret )) && {
	[[ $__expect == $~SHU_PAT_MATH_INT_POS ]] || {
		if \
			(( ${(P)+__expect} )) &&
			[[ "${(Pt)__expect}-" == scalar-* ]] &&
			[[ ${(P)__expect} == $~SHU_PAT_MATH_INT_POS ]]
		then
			__expect=${(P)__expect}
		else
			shu::panic "Not a valid return code: ${__expect}"
		fi
	}

	(( __expect > 255 )) &&
	shu::panic "Not a valid return code: ${__expect}"
}

case $__op in
	(-|)eq|'='|'==')   __op='eq' ;;
	(-|)ne|'!='|'<>')  __op='ne' ;;
	(-|)gl(|ob)|'~')   __op='gl' ;;
	(-|)re(|gex)|'=~') __op='re' ;;
	(-|)le|'<='|'=<')  __op='le' ;;
	(-|)lt|'<')        __op='lt' ;;
	(-|)ge|'>='|'=>')  __op='ge' ;;
	(-|)gt|'>')        __op='gt' ;;
	*) shu::panic "Illegal operator: ${__op}" ;;
esac

[[ $__op == [gl][et] ]] &&
(( ! __compare_ret )) &&
shu::panic "Operator -${__op} can only be used with return codes"

__res=$(
	if (( __discard_fd == 2 )); then
		exec 2> /dev/null
	elif (( __discard_fd == 1 )); then
		exec {fd}>&1
		exec 1> /dev/null
		exec 2>&$fd
	else
		exec 2>&1
	fi

	   SHU_FD_STDOUT=1
	   SHU_FD_STDERR=2
	SHU_PANIC_IGNORE=1
	 SHU_PANIC_TRACE=0

	if (( __eval_cmd )); then
		eval "${(j< >)__cmd}"
	else
		"${(@)__cmd}"
	fi
)
__ret=$?

(( $#__to_assoc )) && {
	     __assoc[return]=$__ret
	     __assoc[result]=$__res
}

(( __compare_ret )) && __res=$__ret

case $__op in
	eq) [[ $__expect == $__res     ]] && __pass=1 ;;
	ne) [[ $__expect != $__res     ]] && __pass=1 ;;
	gl) [[ $__res    == $~__expect ]] && __pass=1 ;;
	re) [[ $__res    =~ $__expect  ]] && __pass=1 ;;
	le) (( __expect  <= __res      )) && __pass=1 ;;
	lt) (( __expect  <  __res      )) && __pass=1 ;;
	ge) (( __expect  >= __res      )) && __pass=1 ;;
	gt) (( __expect  >  __res      )) && __pass=1 ;;
esac

if (( __eval_cmd )); then
	__cmd_str="${(j< >)__cmd}"
else
	__cmd_str="${(j< >)${(@q-)__cmd}}"
fi

__summary="\`${__cmd_str}\`: ${(q-)__expect} -${__op} ${(q-)__res}"

(( $#__to_assoc )) && {
	       __assoc[pass]=${__pass:-0}
	   __assoc[expected]=$__expect
	   __assoc[operator]=$__op
	    __assoc[command]=$__cmd_str
	__assoc[description]=$__desc
	    __assoc[summary]=$__summary

	: ${(PAA)__to_assoc::="${(@kv)__assoc}"}
}

(( __no_desc )) && __desc=$__summary

(( __pass )) && {
	(( __show == -1 || __show == __pass )) &&
	shu:io:putf $__quiet '%s[PASS]%s %s\n' \
		"${SHU_ANSI[fg:green]}" "${SHU_ANSI[reset]}" $__desc
	return 0
}

(( __show == -1 || __show == __pass )) &&
shu:io:putf $__quiet '%s[FAIL]%s %s\n' \
	"${SHU_ANSI[fg:red]}" "${SHU_ANSI[reset]}" $__desc
(( __fail_panics )) && shu::panic 'Assertion failed'
return 1

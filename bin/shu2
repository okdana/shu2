#!/usr/bin/env zsh

#?. shu2 front-end utility v:0.1
#?:
#?= Interact with shu2 library features from the command line.
#?:
#?# usage:
#??   ${0} -h
#??   ${0} -l [<module>]
#??   ${0} -H|-p <function>
#??   ${0} [-qvtTx] [-o <param=val>] <function> [<arg> ...]
#?:
#?# operands:
#?+   <module>        The name of a shu2 module (used to limit `-l` output).
#?+   <function>      The name of a shu2 function.
#?+   <arg> ...       Zero or more arguments to the function.
#?:
#?# options:
#?+   -h              Display this usage help and exit.
#?+   -H              Display documentation for the specified function and exit.
#?+   -l              List all shu2 functions and exit.
#?+   -o <param=val>  Define the value of a special SHU_* parameter.
#?+   -p              Display the path of the specified function and exit.
#?+   -q              Decrease output verbosity.
#?+   -v              Increase output verbosity.
#?+   -t, -x          Enable function xtrace (like `typeset -t`).
#?+   -T, -X          Enable function xtrace (like `typeset -T`).
#?+   -V              Display version information and exit.

if [[ -e ${0:A:h}/../lib ]]; then
  source ${0:A:h}/../lib
else
  source /usr/local/shu2/lib
fi

app::main() {
	local    OPTARG OPTIND opt
	local    mode verbosity=0 xtrace func ret o start end
	local -a options

	while getopts :hHlo:pqtTvxXV opt; do
		case $opt in
			h)   shu:meta:help; return 0 ;;
			H)   mode=doc ;;
			l)   mode=fns ;;
			o)   options+=( $OPTARG ) ;;
			p)   mode=fnpath ;;
			q)   verbosity=-1 ;;
			v)   verbosity=1 ;;
			t|x) xtrace=t ;;
			T|X) xtrace=T ;;
			V)   shu:meta:help -V; return 0 ;;
			':') shu::panic "Missing argument to option: ${(l:2::-:)OPTARG}" ;;
			'?') shu::panic "Invalid option: ${(l:2::-:)OPTARG}" ;;
			*)   shu::panic "Invalid option: ${(l:2::-:)opt}" ;;
		esac
	done

	shift $(( OPTIND - 1 ))

	[[ $mode == fns ]] && {
		shu:meta:fns ${1:-}
		return
	}

	(( $# )) || shu::panic 'Expected function name'

	func="${1#shu:}"
	[[ $func == *:* ]] || func=":${func}"
	func="shu:${func}"
	shift

	typeset -f $func &> /dev/null ||
	shu::panic "Function not found: ${func}"

	(( $#mode && $# )) &&
	shu::panic 'Too many arguments'

	[[ $mode == fnpath ]] && {
		shu:meta:fnpath $func
		return
	}

	[[ $mode == doc ]] && {
		shu:meta:doc $func
		return
	}

	for o in $options; do
		[[ $o == SHU_[A-Z0-9_]##'='* ]] ||
		shu::panic "Illegal option assignment: ${o}"

		[[ -v ${o%%=*} ]] ||
		shu::panic "Unrecognised option: ${o%%=*}"

		typeset "${o%%=*}=${o#*=}"
	done

	(( verbosity > 0 )) &&
	printf >&$SHU_FD_STDERR '%s>>> %s %s%s\n' \
		"${SHU_ANSI[bold:on]}" \
		$func "${(j< >)${(q-)@}}" \
		"${SHU_ANSI[reset]}"

	start=$( shu:time:epoch -u )
	(( $#xtrace )) && typeset -f -$xtrace $func
	() { SHU_PANIC_IGNORE=1; $func "${@}" } "${@}"
	ret=$?
	(( $#xtrace )) && typeset -f +$xtrace $func
	end=$( shu:time:epoch -u )

	(( verbosity )) && {
		if (( ret )); then
			printf >&$SHU_FD_STDERR '%s<<< %s (%d µs)%s\n' \
				"${SHU_ANSI[fg:red]}" \
				$ret $(( end - start )) \
				"${SHU_ANSI[reset]}"
		else
			printf >&$SHU_FD_STDERR '%s<<< %s (%d µs)%s\n' \
				"${SHU_ANSI[fg:green]}" \
				$ret $(( end - start )) \
				"${SHU_ANSI[reset]}"
		fi
	}

	return ret
}

[[ $zsh_eval_context == toplevel ]] && {
	app::main "${@}"
	return
}
:
